// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(cuid())
  name          String
  email         String
  emailVerified Boolean
  image         String?
  bio           String?
  address       String?
  dateOfBirth   DateTime?
  gender        String?
  website       String?
  linkedIn      String?
  twitter       String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  playerProfile PlayerProfile?
  Account       Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

// QuickCourt Business Models

enum UserRole {
  USER
  FACILITY_OWNER
  ADMIN
}

enum FacilityStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BookingStatus {
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum MatchStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum WaitlistStatus {
  WAITING
  PROMOTED
  EXPIRED
}

enum ReportType {
  FACILITY_INAPPROPRIATE_CONTENT
  FACILITY_FALSE_INFORMATION
  FACILITY_SAFETY_CONCERN
  USER_HARASSMENT
  USER_INAPPROPRIATE_BEHAVIOR
  USER_SPAM
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum SportType {
  BADMINTON
  TENNIS
  SQUASH
  BASKETBALL
  FOOTBALL
  CRICKET
  TABLE_TENNIS
  VOLLEYBALL
}

enum VenueType {
  INDOOR
  OUTDOOR
  MIXED
}

model PlayerProfile {
  id          String    @id @default(cuid())
  userId      String    @unique
  role        UserRole  @default(USER)
  phoneNumber String?
  avatar      String?
  isActive    Boolean   @default(true)
  isBanned    Boolean   @default(false)
  bannedUntil DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookings        Booking[]
  ownedFacilities Facility[]        @relation("FacilityOwner")
  waitlistEntries WaitlistEntry[]
  notifications   NotificationLog[]
  facilityReviews FacilityReview[]
  submittedReports Report[] @relation("ReportSubmitter")
  receivedReports  Report[] @relation("ReportTarget")
  paymentOrders   PaymentOrder[]
  bookingReservations BookingReservation[]

  @@map("player_profile")
}

model Facility {
  id              String         @id @default(cuid())
  name            String
  description     String?
  address         String
  latitude        Float?
  longitude       Float?
  amenities       String[]
  photos          String[]
  phone           String?
  email           String?
  policies        String[]
  venueType       VenueType      @default(INDOOR)
  rating          Float?
  reviewCount     Int            @default(0)
  ownerId         String
  status          FacilityStatus @default(PENDING)
  approvedAt      DateTime?
  approvedBy      String?
  rejectionReason String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  owner   PlayerProfile    @relation("FacilityOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  courts  Court[]
  reviews FacilityReview[]
  reports Report[] @relation("ReportedFacility")

  @@index([status])
  @@index([ownerId])
  @@index([rating])
  @@map("facility")
}

model FacilityReview {
  id         String   @id @default(cuid())
  facilityId String
  playerId   String
  rating     Int // 1-5 stars
  comment    String?
  verified   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  facility Facility      @relation(fields: [facilityId], references: [id], onDelete: Cascade)
  player   PlayerProfile @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([facilityId, playerId]) // One review per player per facility
  @@index([facilityId])
  @@index([playerId])
  @@index([rating])
  @@map("facility_review")
}

model Court {
  id                 String    @id @default(cuid())
  name               String
  facilityId         String
  sportType          SportType
  pricePerHour       Float
  operatingStartHour Int // 0-23 (24h format)
  operatingEndHour   Int // 0-23 (24h format)
  isActive           Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  facility       Facility         @relation(fields: [facilityId], references: [id], onDelete: Cascade)
  timeSlots      TimeSlot[]
  bookings       Booking[]
  occupancyStats OccupancyStats[]

  @@index([facilityId])
  @@index([sportType])
  @@map("court")
}

model TimeSlot {
  id                   String   @id @default(cuid())
  courtId              String
  startTime            DateTime
  endTime              DateTime
  price                Float?   // Optional custom price, defaults to court's pricePerHour
  isMaintenanceBlocked Boolean  @default(false)
  maintenanceReason    String?
  version              Int      @default(0) // For optimistic locking
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  court           Court           @relation(fields: [courtId], references: [id], onDelete: Cascade)
  bookings        Booking[]
  waitlistEntries WaitlistEntry[]

  @@unique([courtId, startTime])
  @@index([startTime])
  @@index([courtId])
  @@map("time_slot")
}

model Booking {
  id                 String        @id @default(cuid())
  timeSlotId         String
  courtId            String
  playerId           String
  totalPrice         Float
  status             BookingStatus @default(CONFIRMED)
  paymentSimulated   Boolean       @default(false)
  paymentOrderId     String?       // Reference to payment order
  bookingNotes       String?
  cancelledAt        DateTime?
  cancellationReason String?
  version            Int           @default(0) // For optimistic locking
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  // Relations
  timeSlot TimeSlot      @relation(fields: [timeSlotId], references: [id], onDelete: Cascade)
  court    Court         @relation(fields: [courtId], references: [id], onDelete: Cascade)
  player   PlayerProfile @relation(fields: [playerId], references: [id], onDelete: Cascade)
  paymentOrder PaymentOrder? @relation(fields: [paymentOrderId], references: [id], onDelete: SetNull)
  match    Match?

  @@index([timeSlotId])
  @@index([playerId])
  @@index([courtId])
  @@index([status])
  @@index([createdAt])
  @@index([paymentOrderId])
  @@map("booking")
}

model Match {
  id          String      @id @default(cuid())
  bookingId   String      @unique
  title       String?
  description String?
  maxPlayers  Int         @default(4)
  sportType   SportType
  skillLevel  String? // e.g., "Beginner", "Intermediate", "Advanced"
  status      MatchStatus @default(OPEN)
  startTime   DateTime
  endTime     DateTime
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([sportType])
  @@index([startTime])
  @@map("match")
}

model WaitlistEntry {
  id         String         @id @default(cuid())
  timeSlotId String
  playerId   String
  priority   Int            @default(0) // Lower number = higher priority
  status     WaitlistStatus @default(WAITING)
  notifiedAt DateTime?
  expiresAt  DateTime
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  // Relations
  timeSlot TimeSlot      @relation(fields: [timeSlotId], references: [id], onDelete: Cascade)
  player   PlayerProfile @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([timeSlotId, playerId])
  @@index([timeSlotId, priority])
  @@index([status])
  @@map("waitlist_entry")
}

model OccupancyStats {
  id           String   @id @default(cuid())
  courtId      String
  hourOfWeek   Int // 0-167 (24*7, represents hour of week)
  avgOccupancy Float    @default(0.0) // 0.0 to 1.0
  sampleCount  Int      @default(0)
  lastUpdated  DateTime @default(now())

  // Relations
  court Court @relation(fields: [courtId], references: [id], onDelete: Cascade)

  @@unique([courtId, hourOfWeek])
  @@map("occupancy_stats")
}

model NotificationLog {
  id       String    @id @default(cuid())
  playerId String
  type     String // "waitlist_promotion", "booking_reminder", etc.
  title    String
  message  String
  sentAt   DateTime  @default(now())
  readAt   DateTime?

  // Relations
  player PlayerProfile @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@index([playerId])
  @@index([sentAt])
  @@map("notification_log")
}

model Report {
  id           String       @id @default(cuid())
  type         ReportType
  status       ReportStatus @default(PENDING)
  reason       String
  description  String?
  evidence     String[] // URLs to screenshots or files
  
  // Who submitted the report
  reporterId   String
  reporter     PlayerProfile @relation("ReportSubmitter", fields: [reporterId], references: [id], onDelete: Cascade)
  
  // What/who is being reported (nullable - only one should be set)
  targetUserId   String?
  targetUser     PlayerProfile? @relation("ReportTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  
  targetFacilityId String?
  targetFacility   Facility? @relation("ReportedFacility", fields: [targetFacilityId], references: [id], onDelete: Cascade)
  
  // Admin actions
  reviewedById   String?
  reviewedAt     DateTime?
  reviewNotes    String?
  actionTaken    String? // Description of what action was taken
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([status])
  @@index([type])
  @@index([reporterId])
  @@index([targetUserId])
  @@index([targetFacilityId])
  @@map("report")
}

// Payment and Booking Enhancement Models

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCESSFUL
  FAILED
  REFUNDED
  CANCELLED
}

enum BookingReservationStatus {
  RESERVED
  CONFIRMED
  EXPIRED
  CANCELLED
}

model PaymentOrder {
  id                String        @id @default(cuid())
  razorpayOrderId   String        @unique
  amount            Float         // Amount in INR (paise)
  currency          String        @default("INR")
  receipt           String        // Unique receipt identifier
  status            PaymentStatus @default(PENDING)
  attempts          Int           @default(0)
  
  // Booking context
  playerId          String
  timeSlotIds       String[]      // Array of time slot IDs being booked
  totalPrice        Float         // Total booking price
  
  // Razorpay response data
  razorpayResponse  Json?         // Store complete Razorpay response
  
  // Relations
  player            PlayerProfile @relation(fields: [playerId], references: [id], onDelete: Cascade)
  payments          Payment[]
  bookingReservation BookingReservation?
  bookings          Booking[]
  
  // Timestamps
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  expiresAt         DateTime      // Payment expiry time
  
  @@index([razorpayOrderId])
  @@index([playerId])
  @@index([status])
  @@index([expiresAt])
  @@map("payment_order")
}

model Payment {
  id                  String        @id @default(cuid())
  paymentOrderId      String
  razorpayPaymentId   String        @unique
  razorpaySignature   String?       // For payment verification
  amount              Float         // Amount in paise
  currency            String        @default("INR")
  status              PaymentStatus @default(PENDING)
  method              String?       // Payment method used (card, upi, etc.)
  
  // Payment details from Razorpay
  razorpayResponse    Json?         // Complete payment response
  failureReason       String?       // Failure reason if payment failed
  
  // Verification
  isSignatureVerified Boolean       @default(false)
  verifiedAt          DateTime?
  
  // Relations
  paymentOrder        PaymentOrder  @relation(fields: [paymentOrderId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  
  @@index([razorpayPaymentId])
  @@index([paymentOrderId])
  @@index([status])
  @@map("payment")
}

model BookingReservation {
  id              String                   @id @default(cuid())
  paymentOrderId  String                   @unique
  timeSlotIds     String[]                 // Time slots being reserved
  playerId        String
  status          BookingReservationStatus @default(RESERVED)
  totalPrice      Float
  
  // Reservation details
  reservedAt      DateTime                 @default(now())
  expiresAt       DateTime                 // Reservation expiry (usually 15 minutes)
  confirmedAt     DateTime?                // When booking was confirmed after payment
  
  // Relations
  paymentOrder    PaymentOrder             @relation(fields: [paymentOrderId], references: [id], onDelete: Cascade)
  player          PlayerProfile            @relation(fields: [playerId], references: [id], onDelete: Cascade)
  
  // Timestamps
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  
  @@index([timeSlotIds])
  @@index([playerId])
  @@index([status])
  @@index([expiresAt])
  @@map("booking_reservation")
}
